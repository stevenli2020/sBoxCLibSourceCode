.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OSSL_DESERIALIZER_FROM_BIO 3"
.TH OSSL_DESERIALIZER_FROM_BIO 3 "2020-07-27" "3.0.0-alpha6-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OSSL_DESERIALIZER_from_bio,
OSSL_DESERIALIZER_from_fp,
OSSL_DESERIALIZER_CTX_set_input_type,
OSSL_DESERIALIZER_CTX_add_deserializer,
OSSL_DESERIALIZER_CTX_add_extra,
OSSL_DESERIALIZER_CTX_num_deserializers,
OSSL_DESERIALIZER_INSTANCE,
OSSL_DESERIALIZER_FINALIZER,
OSSL_DESERIALIZER_CLEANER,
OSSL_DESERIALIZER_CTX_set_finalizer,
OSSL_DESERIALIZER_export,
OSSL_DESERIALIZER_INSTANCE_deserializer,
OSSL_DESERIALIZER_INSTANCE_deserializer_ctx
\&\- Routines to perform a deserialization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/deserializer.h>
\&
\& int OSSL_DESERIALIZER_from_bio(OSSL_DESERIALIZER_CTX *ctx, BIO *in);
\& int OSSL_DESERIALIZER_from_fp(OSSL_DESERIALIZER_CTX *ctx, FILE *fp);
\&
\& int OSSL_DESERIALIZER_CTX_set_input_type(OSSL_DESERIALIZER_CTX *ctx,
\&                                          const char *input_type);
\& int OSSL_DESERIALIZER_CTX_add_deserializer(OSSL_DESERIALIZER_CTX *ctx,
\&                                            OSSL_DESERIALIZER *deser);
\& int OSSL_DESERIALIZER_CTX_add_extra(OSSL_DESERIALIZER_CTX *ctx);
\& int OSSL_DESERIALIZER_CTX_num_deserializers(OSSL_DESERIALIZER_CTX *ctx);
\&
\& typedef struct ossl_deserializer_instance_st OSSL_DESERIALIZER_INSTANCE;
\& typedef int (OSSL_DESERIALIZER_FINALIZER)
\&     (OSSL_DESERIALIZER_INSTANCE *deser_inst,
\&      const OSSL_PARAM *params, void *finalize_arg);
\& typedef void (OSSL_DESERIALIZER_CLEANER)(void *finalize_arg);
\&
\& int OSSL_DESERIALIZER_CTX_set_finalizer(OSSL_DESERIALIZER_CTX *ctx,
\&                                         OSSL_DESRIALIZER_FINALIZER *finalizer,
\&                                         OSSL_DESERIALIZER_CLEANER *cleaner,
\&                                         void *finalize_arg);
\&
\& int OSSL_DESERIALIZER_export(OSSL_DESERIALIZER_INSTANCE *deser_inst,
\&                              void *reference, size_t reference_sz,
\&                              OSSL_CALLBACK *export_cb, void *export_cbarg);
\&
\& OSSL_DESERIALIZER *OSSL_DESERIALIZER_INSTANCE_deserializer
\&     (OSSL_DESERIALIZER_INSTANCE *deser_inst);
\& void *OSSL_DESERIALIZER_INSTANCE_deserializer_ctx
\&     (OSSL_DESERIALIZER_INSTANCE *deser_inst);
.Ve
.PP
Feature availability macros:
.IP "\fIOSSL_DESERIALIZER_from_fp()\fR is only available when \fB\s-1OPENSSL_NO_STDIO\s0\fR is undefined." 4
.IX Item "OSSL_DESERIALIZER_from_fp() is only available when OPENSSL_NO_STDIO is undefined."
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\s-1OSSL_DESERIALIZER_CTX\s0\fR holds data about multiple deserializers, as
needed to figure out what the input data is and to attempt to unpack it into
one of several possible related results.  This also includes chaining
deserializers, so the output from one can become the input for another.
This allows having generic format deserializers such as \s-1PEM\s0 to \s-1DER,\s0 as well
as more specialized deserializers like \s-1DER\s0 to \s-1RSA.\s0
.PP
The chains may be limited by specifying an input type, which is considered a
starting point.
This is both considered by \fIOSSL_DESERIALIZER_CTX_add_extra()\fR, which will
stop adding on more deserializer implementations when it has already added
those that take the specified input type, and \fIOSSL_DESERIALIZER_from_bio()\fR,
which will only start the deserializing process with the deserializer
implementations that take that input type.  For example, if the input type
is set to \f(CW\*(C`DER\*(C'\fR, a \s-1PEM\s0 to \s-1DER\s0 deserializer will be ignored.
.PP
The input type can also be \s-1NULL,\s0 which means that the caller doesn't know
what type of input they have.  In this case, \fIOSSL_DESERIALIZER_from_bio()\fR
will simply try with one deserializer implementation after the other, and
thereby discover what kind of input the caller gave it.
.PP
For every deserialization done, even intermediary, a \fIfinalizer\fR
provided by the caller is used to attempt to \*(L"finalize\*(R" the current
deserialization output, which is always a provider side object of some
sort, by \*(L"wrapping\*(R" it into some appropriate type or structure that
the caller knows how to handle.  Exactly what this \*(L"wrapping\*(R" consists
of is entirely at the discretion of the \fIfinalizer\fR.
.PP
\&\fB\s-1OSSL_DESERIALIZER_INSTANCE\s0\fR is an opaque structure that contains
data about the deserializer that was just used, and that may be
useful for the \fIfinalizer\fR.  There are some functions to extract data
from this type, described further down.
.SS "Functions"
.IX Subsection "Functions"
\&\fIOSSL_DESERIALIZER_from_bio()\fR runs the deserialization process for the
context \fIctx\fR, with the input coming from the \fB\s-1BIO\s0\fR \fIin\fR.  The
application is required to set up the \fB\s-1BIO\s0\fR properly, for example to
have it in text or binary mode if that's appropriate.
.PP
\&\fIOSSL_DESERIALIZER_from_fp()\fR does the same thing as \fIOSSL_DESERIALIZER_from_bio()\fR,
except that the input is coming from the \fB\s-1FILE\s0\fR \fIfp\fR.
.PP
\&\fIOSSL_DESERIALIZER_CTX_add_deserializer()\fR populates the \fB\s-1OSSL_DESERIALIZER_CTX\s0\fR
\&\fIctx\fR with a deserializer, to be used to attempt to deserialize some
serialized input.
.PP
\&\fIOSSL_DESERIALIZER_CTX_add_extra()\fR finds deserializers that generate
input for already added deserializers, and adds them as well.  This is
used to build deserializer chains.
.PP
\&\fIOSSL_DESERIALIZER_CTX_set_input_type()\fR sets the starting input type.  This
limits the deserializer chains to be considered, as explained in the general
description above.
.PP
\&\fIOSSL_DESERIALIZER_CTX_num_deserializers()\fR gets the number of
deserializers currently added to the context \fIctx\fR.
.PP
\&\fIOSSL_DESERIALIZER_CTX_set_finalizer()\fR sets the \fIfinalizer\fR function
together with the caller argument for the finalizer, \fIfinalize_arg\fR,
as well as \fIcleaner\fR, the function to clean up \fIfinalize_arg\fR when
the deserialization has concluded.
.PP
\&\fIOSSL_DESERIALIZER_export()\fR is a fallback function for \fIfinalizers\fR
that can't use the data they get directly for diverse reasons.  It
takes the same deserialize instance \fIdeser_inst\fR that the
\&\fIfinalizer\fR got and an object \fIreference\fR, unpacks the object that
refers to, and exports it by creating an \s-1\fIOSSL_PARAM\s0\fR\|(3) array that
it then passes to \fIexport_cb\fR, along with \fIexport_arg\fR.
.PP
\&\fIOSSL_DESERIALIZER_INSTANCE_deserializer()\fR can be used to get the
deserializer method from a deserializer instance \fIdeser_inst\fR.
.PP
OSSL_DESERIALIZER_INSTANCE_deserializer\-\fIctx()\fR can be used to get the
deserializer method's provider context from a deserializer instance
\&\fIdeser_inst\fR.
.SS "Finalizer"
.IX Subsection "Finalizer"
The \fIfinalizer\fR gets the following arguments:
.IP "\fIdeser_inst\fR" 4
.IX Item "deser_inst"
The \fB\s-1OSSL_DESERIALIZER_INSTANCE\s0\fR for the deserializer from which
\&\fIfinalizer\fR gets its data.
.IP "\fIparams\fR" 4
.IX Item "params"
The data produced by the deserializer, further described below.
.IP "\fIfinalize_arg\fR" 4
.IX Item "finalize_arg"
The pointer that was set with \fIOSSL_DESERIALIZE_CTX_set_finalizer()\fR as
\&\fIfinalize_arg\fR.
.PP
The \fIfinalizer\fR is expected to return 1 when the data it receives can
be \*(L"finalized\*(R", otherwise 0.
.PP
The globally known parameters that \fIfinalize\fR can get in \fIparams\fR
are:
.ie n .IP """data-type"" (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA_TYPE\s0\fR) <\s-1UTF8\s0 string>" 4
.el .IP "``data-type'' (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA_TYPE\s0\fR) <\s-1UTF8\s0 string>" 4
.IX Item "data-type (OSSL_DESERIALIZER_PARAM_DATA_TYPE) <UTF8 string>"
This is a detected content type that some deserializers may provide.
For example, \s-1PEM\s0 input sometimes has a type specified in its header,
and some deserializers may add that information as this parameter.
This is an optional parameter, but may be useful for extra checks in
the \fIfinalizer\fR.
.ie n .IP """data"" (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA\s0\fR) <octet string>" 4
.el .IP "``data'' (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA\s0\fR) <octet string>" 4
.IX Item "data (OSSL_DESERIALIZER_PARAM_DATA) <octet string>"
The deserialized data itself, as an octet string.  This is produced by
deserializers when it's possible to pass an object in this form.  Most
often, this is simply meant to be passed to the next deserializer in a
chain, but could be considered final data as well, at the discretion
of the \fIfinalizer\fR.
.ie n .IP """reference"" (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA\s0\fR) <octet string>" 4
.el .IP "``reference'' (\fB\s-1OSSL_DESERIALIZER_PARAM_DATA\s0\fR) <octet string>" 4
.IX Item "reference (OSSL_DESERIALIZER_PARAM_DATA) <octet string>"
The deserialized data itself, as a reference to an object.  The
reference itself is an octet string, and can be passed to other
operations and functions within the same provider as the one that
provides \fIdeser\fR.
.PP
At least one of \*(L"data\*(R" or \*(L"reference\*(R" must be present, and it's
possible that both can be.  A \fIfinalizer\fR should choose to use the
\&\*(L"reference\*(R" parameter if possible, otherwise the \*(L"data\*(R" parameter.
.PP
If it's not possible to use the \*(L"reference\*(R" parameter, but that's
still what a \fIfinalizer\fR wants to do, it is possible to use
\&\fIOSSL_DESERIALIZER_export()\fR as a fallback.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIOSSL_DESERIALIZER_from_bio()\fR and \fIOSSL_DESERIALIZER_from_fp()\fR return 1 on
success, or 0 on failure.
.PP
\&\fIOSSL_DESERIALIZER_CTX_add_deserializer()\fR,
\&\fIOSSL_DESERIALIZER_CTX_add_extra()\fR, and
\&\fIOSSL_DESERIALIZER_CTX_set_finalizer()\fR return 1 on success, or 0 on
failure.
.PP
\&\fIOSSL_DESERIALIZER_CTX_num_deserializers()\fR returns the current
number of deserializers.  It returns 0 if \fIctx\fR is \s-1NULL.\s0
.PP
\&\fIOSSL_DESERIALIZER_export()\fR returns 1 on success, or 0 on failure.
.PP
\&\fIOSSL_DESERIALIZER_INSTANCE_deserializer()\fR returns an
\&\fB\s-1OSSL_DESERIALIZER\s0\fR pointer on success, or \s-1NULL\s0 on failure.
.PP
\&\fIOSSL_DESERIALIZER_INSTANCE_deserializer_ctx()\fR returns a provider
context pointer on success, or \s-1NULL\s0 on failure.>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIprovider\fR\|(7), \s-1\fIOSSL_DESERIALIZER_CTX\s0\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
The functions described here were added in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
