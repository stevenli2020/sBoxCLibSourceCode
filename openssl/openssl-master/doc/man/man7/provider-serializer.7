.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PROVIDER-SERIALIZER 7"
.TH PROVIDER-SERIALIZER 7 "2020-07-27" "3.0.0-alpha6-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
provider\-serializer \- The SERIALIZER library <\-> provider functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/core_dispatch.h>
\&
\& /*
\&  * None of these are actual functions, but are displayed like this for
\&  * the function signatures for functions that are offered as function
\&  * pointers in OSSL_DISPATCH arrays.
\&  */
\&
\& /* Functions to construct / destruct / manipulate the serializer context */
\& void *OSSL_FUNC_serializer_newctx(void *provctx);
\& void OSSL_FUNC_serializer_freectx(void *ctx);
\& int OSSL_FUNC_serializer_set_ctx_params(void *ctx, const OSSL_PARAM params[]);
\& const OSSL_PARAM *OSSL_FUNC_serializer_settable_ctx_params(void)
\&
\& /* Functions to serialize object data */
\& int OSSL_FUNC_serializer_serialize_data(void *ctx, const OSSL_PARAM *data,
\&                                         OSSL_CORE_BIO *out,
\&                                         OSSL_PASSPHRASE_CALLBACK *cb,
\&                                         void *cbarg);
\& int OSSL_FUNC_serializer_serialize_object(void *ctx, void *obj, OSSL_CORE_BIO *out,
\&                                           OSSL_PASSPHRASE_CALLBACK *cb,
\&                                           void *cbarg);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1SERIALIZER\s0 is a generic method to serialize any set of object data
in \s-1\fIOSSL_PARAM\s0\fR\|(3) array form, or any provider side object into
serialized form, and write it to the given \s-1OSSL_CORE_BIO.\s0  If the caller wants
to get the serialized stream to memory, it should provide a
\&\fIBIO_s_membuf\fR\|(3).
.PP
The serializer doesn't need to know more about the \fB\s-1OSSL_CORE_BIO\s0\fR pointer than
being able to pass it to the appropriate \s-1BIO\s0 upcalls (see
\&\*(L"Core functions\*(R" in \fIprovider\-base\fR\|(7)).
.PP
The serialization using the \s-1\fIOSSL_PARAM\s0\fR\|(3) array form allows a
serializer to be used for data that's been exported from another
provider, and thereby allow them to exist independently of each
other.
.PP
The serialization using a provider side object can only be safely used
with provider data coming from the same provider, for example keys
with the \s-1KEYMGMT\s0 provider.
.PP
All \*(L"functions\*(R" mentioned here are passed as function pointers between
\&\fIlibcrypto\fR and the provider in \fB\s-1OSSL_DISPATCH\s0\fR arrays via
\&\fB\s-1OSSL_ALGORITHM\s0\fR arrays that are returned by the provider's
\&\fIprovider_query_operation()\fR function
(see \*(L"Provider Functions\*(R" in \fIprovider\-base\fR\|(7)).
.PP
All these \*(L"functions\*(R" have a corresponding function type definition
named \fBOSSL_{name}_fn\fR, and a helper function to retrieve the
function pointer from a \fB\s-1OSSL_DISPATCH\s0\fR element named
\&\fBOSSL_FUNC_{name}\fR.
For example, the \*(L"function\*(R" \fIOSSL_FUNC_serializer_serialize_data()\fR has these:
.PP
.Vb 6
\& typedef int
\&     (OSSL_FUNC_serializer_serialize_data_fn)(void *provctx,
\&                                            const OSSL_PARAM params[],
\&                                            OSSL_CORE_BIO *out);
\& static ossl_inline OSSL_FUNC_serializer_serialize_data_fn
\&     OSSL_FUNC_serializer_serialize_data(const OSSL_DISPATCH *opf);
.Ve
.PP
\&\fB\s-1OSSL_DISPATCH\s0\fR arrays are indexed by numbers that are provided as
macros in \fIopenssl\-core_dispatch.h\fR\|(7), as follows:
.PP
.Vb 4
\& OSSL_FUNC_serializer_newctx              OSSL_FUNC_SERIALIZER_NEWCTX
\& OSSL_FUNC_serializer_freectx             OSSL_FUNC_SERIALIZER_FREECTX
\& OSSL_FUNC_serializer_set_ctx_params      OSSL_FUNC_SERIALIZER_SET_CTX_PARAMS
\& OSSL_FUNC_serializer_settable_ctx_params OSSL_FUNC_SERIALIZER_SETTABLE_CTX_PARAMS
\&
\& OSSL_FUNC_serializer_serialize_data      OSSL_FUNC_SERIALIZER_SERIALIZE_DATA
\& OSSL_FUNC_serializer_serialize_object    OSSL_FUNC_SERIALIZER_SERIALIZE_OBJECT
.Ve
.SS "Names and properties"
.IX Subsection "Names and properties"
The name of an implementation should match the type of object it
handles.  For example, an implementation that serializes an \s-1RSA\s0 key
should be named accordingly.
.PP
To be able to specify exactly what serialization format and what type
of data a serializer implementation is expected to handle, two
additional properties may be given:
.IP "format" 4
.IX Item "format"
This property is used to specify what kind of output format the
implementation produces.  Currently known formats are:
.RS 4
.IP "text" 4
.IX Item "text"
An implementation with that format property value outputs human
readable text, making that implementation suitable for \f(CW\*(C`\-text\*(C'\fR output
in diverse \fIopenssl\fR\|(1) commands.
.IP "pem" 4
.IX Item "pem"
An implementation with that format property value outputs \s-1PEM\s0
formatted data.
.IP "der" 4
.IX Item "der"
An implementation with that format property value outputs \s-1DER\s0
formatted data.
.RE
.RS 4
.RE
.IP "type" 4
.IX Item "type"
With objects that have multiple purposes, this can be used to specify
the purpose type.  The currently known use cases are asymmetric keys
and key parameters, where the type can be one of:
.RS 4
.IP "private" 4
.IX Item "private"
An implementation with that format property value outputs a private
key.
.IP "public" 4
.IX Item "public"
An implementation with that format property value outputs a public
key.
.IP "parameters" 4
.IX Item "parameters"
An implementation with that format property value outputs key
parameters.
.RE
.RS 4
.RE
.PP
The possible values of both these properties is open ended.  A
provider may very well specify other formats that libcrypto doesn't
know anything about.
.SS "Context functions"
.IX Subsection "Context functions"
\&\fIOSSL_FUNC_serializer_newctx()\fR returns a context to be used with the rest of
the functions.
.PP
\&\fIOSSL_FUNC_serializer_freectx()\fR frees the given \fIctx\fR, if it was created by
\&\fIOSSL_FUNC_serializer_newctx()\fR.
.PP
\&\fIOSSL_FUNC_serializer_set_ctx_params()\fR sets context data according to
parameters from \fIparams\fR that it recognises.  Unrecognised parameters
should be ignored.
.PP
\&\fIOSSL_FUNC_serializer_settable_ctx_params()\fR returns a constant \fB\s-1OSSL_PARAM\s0\fR
array describing the parameters that \fIOSSL_FUNC_serializer_set_ctx_params()\fR
can handle.
.PP
See \s-1\fIOSSL_PARAM\s0\fR\|(3) for further details on the parameters structure used
by \fIOSSL_FUNC_serializer_set_ctx_params()\fR and \fIOSSL_FUNC_serializer_settable_ctx_params()\fR.
.SS "Serializing functions"
.IX Subsection "Serializing functions"
\&\fIOSSL_FUNC_serializer_serialize_data()\fR should take an array of \fB\s-1OSSL_PARAM\s0\fR,
\&\fIdata\fR, and if it contains the data necessary for the object type
that the implementation handles, it should output the object in
serialized form to the \fB\s-1OSSL_CORE_BIO\s0\fR.
.PP
\&\fIOSSL_FUNC_serializer_serialize_object()\fR should take a pointer to an object
that it knows intimately, and output that object in serialized form to
the \fB\s-1OSSL_CORE_BIO\s0\fR.  The caller \fImust\fR ensure that this function is called
with a pointer that the provider of this function is familiar with.
It is not suitable to use with object pointers coming from other
providers.
.PP
Both serialization functions also take an \fB\s-1OSSL_PASSPHRASE_CALLBACK\s0\fR
function pointer along with a pointer to application data \fIcbarg\fR,
which should be used when a pass phrase prompt is needed.
.SS "Serializer parameters"
.IX Subsection "Serializer parameters"
Parameters currently recognised by built-in serializers are as
follows:
.ie n .IP """cipher"" (\fB\s-1OSSL_SERIALIZER_PARAM_CIPHER\s0\fR) <\s-1UTF8\s0 string>" 4
.el .IP "``cipher'' (\fB\s-1OSSL_SERIALIZER_PARAM_CIPHER\s0\fR) <\s-1UTF8\s0 string>" 4
.IX Item "cipher (OSSL_SERIALIZER_PARAM_CIPHER) <UTF8 string>"
The name of the encryption cipher to be used when generating encrypted
serialization.  This is used when serializing private keys, as well as
other objects that need protection.
.Sp
If this name is invalid for the serialization implementation, the
implementation should refuse to perform the serialization, i.e.
\&\fIOSSL_FUNC_serializer_serialize_data()\fR and \fIOSSL_FUNC_serializer_serialize_object()\fR
should return an error.
.ie n .IP """properties"" (\fB\s-1OSSL_SERIALIZER_PARAM_PROPERTIES\s0\fR) <\s-1UTF8\s0 string>" 4
.el .IP "``properties'' (\fB\s-1OSSL_SERIALIZER_PARAM_PROPERTIES\s0\fR) <\s-1UTF8\s0 string>" 4
.IX Item "properties (OSSL_SERIALIZER_PARAM_PROPERTIES) <UTF8 string>"
The properties to be queried when trying to fetch the algorithm given
with the \*(L"cipher\*(R" parameter.
This must be given together with the \*(L"cipher\*(R" parameter to be
considered valid.
.Sp
The serialization implementation isn't obligated to use this value.
However, it is recommended that implementations that do not handle
property strings return an error on receiving this parameter unless
its value \s-1NULL\s0 or the empty string.
.ie n .IP """passphrase"" (\fB\s-1OSSL_SERIALIZER_PARAM_PASS\s0\fR) <octet string>" 4
.el .IP "``passphrase'' (\fB\s-1OSSL_SERIALIZER_PARAM_PASS\s0\fR) <octet string>" 4
.IX Item "passphrase (OSSL_SERIALIZER_PARAM_PASS) <octet string>"
A pass phrase provided by the application.  When this is given, the
built-in serializers will not attempt to use the passphrase callback.
.PP
Parameters currently recognised by the built-in pass phrase callback:
.ie n .IP """info"" (\fB\s-1OSSL_PASSPHRASE_PARAM_INFO\s0\fR) <\s-1UTF8\s0 string>" 4
.el .IP "``info'' (\fB\s-1OSSL_PASSPHRASE_PARAM_INFO\s0\fR) <\s-1UTF8\s0 string>" 4
.IX Item "info (OSSL_PASSPHRASE_PARAM_INFO) <UTF8 string>"
A string of information that will become part of the pass phrase
prompt.  This could be used to give the user information on what kind
of object it's being prompted for.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIOSSL_FUNC_serializer_newctx()\fR returns a pointer to a context, or \s-1NULL\s0 on
failure.
.PP
\&\fIOSSL_FUNC_serializer_set_ctx_params()\fR returns 1, unless a recognised
parameters was invalid or caused an error, for which 0 is returned.
.PP
\&\fIOSSL_FUNC_serializer_settable_ctx_params()\fR returns a pointer to an array of
constant \fB\s-1OSSL_PARAM\s0\fR elements.
.PP
\&\fIOSSL_FUNC_serializer_serialize_data()\fR and \fIOSSL_FUNC_serializer_serialize_object()\fR
return 1 on success, or 0 on failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIprovider\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The \s-1SERIALIZER\s0 interface was introduced in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
